主要考察了性质观察以及动态规划的相关内容。

### 10pts

直接输出 $p$ 即可。

### 20pts

通过爆搜，每次暴力枚举括号插入位置。

### 40pts

通过状态压缩DP，记录插入 $k$ 次操作以后，所有括号序列得到的概率，时间复杂度为 $O(n \times 2^{2n})$，实际复杂度远小于这个值，因为并不是所有括号匹配都能够最终得到。

### 70pts

容易发现，括号序列一共有 $1⋅3⋅5...⋅(2𝑛−1)$ 种生成方式。

假如 `(` 为 $1$，`)` 为 $−1$，那么一个序列合法的充要条件为：最小前缀和为 $0$，且以 $0$ 结尾。

现在考虑维护这些前缀和。

如果我们在当前序列某一位后插入一个 `()`，且那一位的前缀和为 $𝑥$,那么相当于把 $𝑥$ 替换成 $[𝑥,𝑥+1,𝑥]$。

同理可知，插入 `)(` 相当于把 $𝑥$ 替换成 $[𝑥,𝑥−1,𝑥]$​。

我们观察到每次选中的数概率是均等的，所以我们并不关心数的顺序，只关心这个前缀和数组中每个数出现了多少次。

定义 $𝑓_{𝑛,𝑥}$ 为前缀和数组一开始只有一个数，这个数为 $x$，执行 $𝑛$ 次操作以后得到的前缀和数组中每个元素均不小于 $0$ 的概率。

有两种转移，第一种下一步变成了 $x,x+1,x$，那么概率为
$$
\sum_{1 \leq i+j+k \leq n-1} f_{i,x} \times f_{j,x+1} \times f_{k,x+1} \times C_{i+j+k}^i \times C_{j+k}^j \times p
$$


第一种下一步变成了 $x,x-1,x$​，那么概率为
$$
\sum_{1 \leq i+j+k \leq n-1} f_{i,x} \times f_{j,x-1} \times f_{k,x+1} \times C_{i+j+k}^i \times C_{j+k}^j \times (1-p)
$$
最终答案即为 $f_{0,n}$，时间复杂度为 $O(n^2)$。

### 100pts

只需要将上面的 DP 过程优化即可，优化的思路很多，以下给出一种。

以第一种转移为例，引入辅助DP数组 $g$。
$$
g_{n,x}=\sum_{1 \leq i+j \leq n} f_{i,x} \times f_{j,x+1} \times C_{n}^i
$$
$g$ 的计算是 $O(n^3)$ 的，再通过 $g$ 计算第一种情况：
$$
\sum_{1 \leq i+j \leq n} g_{i,x} \times f_{j,x} \times C_{n}^i
$$
相当于对于 $i,j,k$ 三维不一起枚举，先合并 $i,j$，再合并 $j,k$，时间复杂度为 $O(n^3)$。
