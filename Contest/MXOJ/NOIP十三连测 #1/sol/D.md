### 50pts

可以按如下方式进行DP，考虑 $f_{i,j,k}$ 表示跨过 $i$ 号点，梦梦执行了 $j$ 次操作，熊熊执行了 $k$ 次操作，且 $[1,i]$ 编号内的所有白魔法全都满足要求的情况下，当前的最小消耗是多少。

注意到 $a_i \leq 10$，这个过程中 $j \in [0,10],k \in [0,10]$，利用滚动数组，时间复杂度为 $O(n \times M^2)$，其中 $M$ 为值域。

### 100pts

考虑可能的白魔法序列 $b$ 满足什么条件，可以考虑反向操作，将这个序列减为 $0$。 考虑差分，如果 $b_i > b_{i+1}$，那么至少要进行 $b_i − b_{i+1}$ 次前缀 $i$ 减一的操作。反之亦然。 上述操作完之后，所有的元素都变成相同，如果这个时候 $b$ 非负，那么满足条件。 为了方便，我们在序列开头和末尾添加两个足够大的元素 $b_0 = b_{n+1} = M$，上述条件就是 $b_0 ≥ ∑_n ^i=\max(0, b_i − b_{i+1})$。

因为 $b_0=b_{n+1}=M$ 足够大，所以上述条件可以转化为
$$
\sum_{i=0}^n |b_i-b_{i+1}| \leq 2M
$$
在原问题中，代价总和就等于 $b_i$ 之和，所以问题可以转化为，可以花 $1$ 的代价让 $a_i$ 加上 $1$，问最少的代价满足上述条件。

令 $F = \sum_{i=0}^n |a_i − a_{i+1}|$。每次我们可以选择一段极长的相 同的 $a_l = a_{l+1} = · · · = a_r$，并且 $a_{l−1} > a_l , a_{r+1} > a_r$，将这一段加一就能将 $F$ 整体地减少 $2$。这样操作的代价为这一段的长度。 我们贪心地找这样最短的极长段即可，可以对这一段加，然后加到这一段与两头的某个数字相同为止。一直做到 $F$ 不超过 $2M$。 考虑段合并的过程，最后一定是所有数和最大的元素合并， 往前就是左右两边独立合并。这个与笛卡尔树比较类似。 我们求出笛卡尔树之后，就能快速得到所有段合并的过程， 并且从短到长贪心即可。时间复杂度 $O(n)$。
